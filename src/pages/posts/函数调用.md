---
layout: '../../layouts/MarkdownPost.astro'
title: '函数调用'
pubDate: 2024-03-04
description: '函数调用'
author: '保安'
cover:
  url: '../img/cc.jpg'
  square: '../img/cc.jpg'
  twitter: '../img/cc.jpg'
  alt: 'cover'
tags: [ "JS基础" ]
theme: 'dark'
featured: true
---

![封面|wide](/img/cc.jpg)[1]

## 函数调用

```javascript
function foo() {}

var bar = () => {}
```

无论是函数声明还是用箭头函数，都能创建一个函数体。

函数也是一个数据，每一个函数体都是一个**对象**，在代码解析阶段创建，被持久的**存储在内存之中**。

也就是说，程序在运行过程中，函数体这个对象始终存在。

因此，我们可以在程序**运行的任何时候**调用该声明的函数。

在其他语言中，例如Java，函数声明会在代码打包的过程中就解析好了，因此**函数是静态的**，
在内存中会专门提供一个**静态的方法区**去存放函数体。
但是在JS是在代码**运行过程中**对函数进行解析的，因此在内存分配中，JS并没有一个类似方法区的静态区域来存储函数体。
而是**将函数体看成一个对象**，存放于**堆内存**中。

函数其实是一个特殊的对象，因为它具备对象的所有特征。

## 函数是一个特殊的对象

1. 函数可以属性赋值
```javascript
function MaFeiFei () {
    console.log("I'm a mafeifei")
}
MaFeiFei.biubiubiu = '98K'
console.log(MaFeiFei.biubiubiu) // 98k
```
2. 函数可以作为参数来传递

```javascript
function runningman (name) {
    console.log("人恨话不多，请叫我:",name)
}

function PD (project, name) {
    project && project(name)
}

PD(runningman, '开哥') // 人恨话不多，请叫我:开哥

// 常用于callback函数。 callback && callback(arguments)
```

3. 函数可以作为返回值
```javascript
function mute (mode) {
    return function vibration(size) {
        return console.log(`现在的模式是:`,mode,',震动太小是:',size)
    }
}
// 返回值的函数可以是匿名函数，但是声明通常是为了好打断点排错。
// 知道是哪个函数名体内出现了异常。
```

## 函数执行上下文

通常说，函数形成完成后，所占用的内存空间会被GC回收，说的就是执行上下文所占用的内存空间。

为什么是说函数调用栈呢，因为JS的引擎，使用栈的方式来管理与跟踪多个上下文的运行情况，并保证在程序运行的过程中，**栈底一定是全局上下文，并且不会出栈。**
栈顶一定是当前正在执行的上下文，**并且正在执行的上下文始终都会在栈顶**。 

相当于是一个流水线，无论什么时候，只会且仅会有一个上下文正在执行。如果遇到了新的函数，那么就创建新的上下文，并推入到栈顶，栈顶上下文执行完毕后，就会出键，并被垃圾回收GC回收，新的栈顶上下文继续执行。

栈空间的分配是从高位向下分配。

| 地址高位               | 栈内存的使用从内存高位开始 |
|--------------------|---------------|
| 1000(其实应该用16进制来表示) | ⬇             |
| 999                |               |
| 998                |               |
| ...                |               |
| 3                  |               |
| 2                  |               |
| 1                  | ⬆             |
| 地址低位               | 堆内存的使用从内存低位开始 |

